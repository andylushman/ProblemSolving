<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Practice questions</title>
  </head>
  <body>
    <script type="text/javascript">
//***************************************
// Write a function, which takes a non-negative integer (seconds) as input and returns the time in a human-readable format (HH:MM:SS)
// HH = hours, padded to 2 digits, range: 00 - 99
// MM = minutes, padded to 2 digits, range: 00 - 59
// SS = seconds, padded to 2 digits, range: 00 - 59
// The maximum time never exceeds 359999 (99:59:59)
// You can find some examples in the test fixtures.

function humanReadabl(seconds){
  //HH:MM:SS
  let secCount = 0;
  let minCount = 0;
  let hourCount = 0;

  let time //HH:MM:SS


  for (let i = 0; i <= seconds; i++) {
    secCount ++;
    if (secCount === 60) {
      secCount = 0;
      minCount ++;
      if (minCount === 60) {
        minCount = 0;
        hourCount ++
      }
    }
  }

  console.log(time);
  console.log(hourCount + ":" + minCount + ":" + secCount);
};
humanReadabl(4051);
//***************************************
// Once upon a time, on a way through the old wild west,…
//
// … a man was given directions to go from one point to another. The directions were "NORTH", "SOUTH", "WEST", "EAST". Clearly "NORTH" and "SOUTH" are opposite, "WEST" and "EAST" too. Going to one direction and coming back the opposite direction is a needless effort. Since this is the wild west, with dreadfull weather and not much water, it's important to save yourself some energy, otherwise you might die of thirst!

function dirReduc (arr) {
  for (var i = 0; i < arr.length - 1; i++) {
    if (arr[i] !== arr[i+1] && arr[i].length === arr[i+1].length) {
      arr.splice(i,2);
      i = -1;
    }
  }
  return arr;
};
//***************************************
// Given the string representations of two integers, return the string representation of the sum of those integers.
//
// For example:
//
// sumStrings('1','2') => '3'
function sumStrings(num1, num2){
  while (num1.length > 1 && num1[0] === '0')
    num1 = num1.slice(1);

  while (num2.length > 1 && num2[0] === '0')
    num2 = num2.slice(1);

  num1 = num1.split('').reverse().join('');
  num2 = num2.split('').reverse().join('');

  var add = 0
    , ans = '';
  for (var i = 0, len = num1.length > num2.length ? num1.length : num2.length; i < len; i++) {
    var a = i < num1.length ? Number(num1[i]) : 0
      , b = i < num2.length ? Number(num2[i]) : 0;

    var c = a + b + add;
    ans += c % 10;
    add = c >= 10 ? 1 : 0;
  }

  if (add) ans += add;

  return ans.split('').reverse().join('');
}
//***************************************
// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
// Finish the solution so that it returns the sum of all the multiples of 3 or 5 below the number passed in.
// Note: If the number is a multiple of both 3 and 5, only count it once.

function solution(num) {

  let returnArray = [];
  let total = 0;

  for (let i = 1; i < num; i++) {
    if (i % 3 === 0 && i % 5 === 0) {
      returnArray.push(i);
    }
    if (i % 3 === 0 && !(i % 5 === 0 )) {
      returnArray.push(i);;
    }
    if (i % 5 === 0 && !(i % 3 === 0)) {
      returnArray.push(i);
    }
  }

  for (let i = 0; i < returnArray.length; i++) {
    total += returnArray[i];
  }

  console.log(total);
  return (total);
};
//***************************************
// Create a function that takes a Roman numeral as its argument and returns its value as a numeric decimal integer. You don't need to validate the form of the Roman numeral.

// Modern Roman numerals are written by expressing each decimal digit of the number to be encoded separately, starting with the leftmost digit and skipping any 0s. So 1990 is rendered "MCMXC" (1000 = M, 900 = CM, 90 = XC) and 2008 is rendered "MMVIII" (2000 = MM, 8 = VIII). The Roman numeral for 1666, "MDCLXVI", uses each letter in descending order.

// Example:
// solution('XXI'); // should return 21
function romanNumerals(romanNum){
  const roman = {
    M: 1000,
    D: 500,
    C: 100,
    L: 50,
    X: 10,
    V: 5,
    I: 1
  };

  let romanNumeral = 0;
  let currentRM = null;

  //letters give an array of roman numerals
  const letters = romanNum.split("");
  // console.log(letters);
  let numbers = [];
  //Takes the iterator and creates a letter which in turn makes a number in the roman object
  for (let i = 0; i < letters.length; i++) {
    numbers.push(roman[letters[i]]);
  }
  console.log(numbers);
  for (let i = 0; i < numbers.length; i++) {
    if (currentRM >= numbers[i] || currentRM === null) {
      currentRM = numbers[i];
      romanNumeral += numbers[i];
    } else {
      currentRM = numbers[i];
      romanNumeral = numbers[i] - romanNumeral;
    }
  }
  console.log(romanNumeral);
  return romanNumeral;
};
//***************************************
      //FizzBuzz
      function fizzBuzz(){
        for (let i = 0; i < 100; i ++){
          if(i % 3 === 0 && i % 5 === 0){
            console.log("FizzBuzz");
          } else if (i % 3 === 0) {
            console.log("Fizz");
          } else if (i % 5 === 0) {
            console.log("Buzz");
          } else {
            console.log(i);
          };
        };
      }
//***************************************

      //Write word backwords
      function reverseWord(str){
        const word = str.split("").reverse("").join("");
        console.log(word);
      }
//***************************************

      /* 7kyu Regex Validate Pin Code: ATM machines allow 4 or 6 digit PIN codes and PIN codes cannot contain anything but exactly 4 digits or exactly 6 digits. If the function is passed a valid PIN string, return true, else return false. */

      function validatePIN (pin) {
        if (!isNaN(pin) && pin.length === 4 || pin.length === 6){
          return true;
        } else {
          return false;
        }
      }
//***************************************

      /* Friend or Foe?: Make a program that filters a list of strings and returns a list with only your friends name in it.

      If a name has 4 letters in it, you can be sure that it has to be a friend of yours!

      Ex: Input = ["Ryan", "Kieran", "Jason", "Yous"], Output = ["Ryan", "Yous"] */

      function friend(friends){
        var friendsArr = [];
        for (var i = 0; i < friends.length; i++) {
          if (friends[i].length === 4) {
            friendsArr.push(friends[i]);
          }
        }
        return friendsArr;
      }
//***************************************

      /* 8kyu Complete the bool_to_word (Javascript: boolToWord ) method.

      Given: a boolean value

      Return: a 'Yes' string for true and a 'No' string for false */

      function boolToWord(bool){
        if(bool === true){
          return "Yes";
        } else if (bool === false) {
          return "No";
        }
      }
//***************************************
// Write a function that takes an integer and returns an array [A, B, C], where A is the number of multiples of 3 (but not 5) less than the given integer, B is the number of multiples of 5 (but not 3) less than the given integer and C is the number of multiples of 3 and 5 less than the given integer.
// For example, solution(20) should return [5, 2, 1]
function solution(num){
  let returnArray = [];
  let ACount = 0;
  let BCount = 0;
  let CCount = 0;

  for (var i = 1; i < num; i++) {
    if (i % 3 === 0 && i % 5 === 0) {
      CCount ++;
    }
    if (i % 3 === 0 && !(i % 5 === 0 )) {
      ACount ++;
    }
    if (i % 5 === 0 && !(i % 3 === 0)) {
      BCount ++;
    }
  }

  returnArray.push(ACount, BCount, CCount);

  return (returnArray);
};
//***************************************
// Given two arrays a and b write a function comp(a, b) (compSame(a, b) in Clojure) that checks whether the two arrays have the "same" elements, with the same multiplicities. "Same" means, here, that the elements in b are the elements in a squared, regardless of the order.
function comp(array1, array2){
  let array1Squared = [];
  var found = false;
  //Square values in first array and save them in array1Squared
  for (let i = 0; i < array1.length; i++) {
    array1Squared.push(Math.pow(array1[i],2));
  }
  //
  for (let j = 0; j < array2.length; j++) {
      if (array1Squared.indexOf(array2[j]) > -1) {
          found = true;
          console.log(array2[j]);
      }
  }
};
//***************************************
//Complete the solution so that it reverses all of the words within the string passed in.
// Example:
// reverseWords("The greatest victory is that which requires no battle")
// // should return "battle no requires which that is victory greatest The"

function reverseWords(str){
  const word = str.split(" ").reverse("").join(" ");
  console.log(word);
  return word; //words reversed
};
//***************************************
// In this Kata, you will be given a string that has lowercase letters and numbers. Your task is to compare the number groupings and return the largest number.
//
// For example, solve("gh12cdy695m1") = 695, because this is the largest of all number groupings.

function solve(str) {
  let largestNumber = null;
  let numbers = [];

  for (let i = 0; i < str.length; i++) {
    if (!isNaN(str[i])) {
      numbers.push(parseInt(str[i]));
    } else if (numbers.length > 0) {
        let fullNumber = parseInt(numbers.join(''));
        if (fullNumber > largestNumber || largestNumber === null) {
          largestNumber = fullNumber;
        }
        numbers = [];
      }
  }
  if (numbers.length > 0) {
    if (parseInt(numbers.join('')) > largestNumber) {
      largestNumber = parseInt(numbers.join(''));
    }
  }
  console.log(largestNumber);
};
//***************************************
    //Find the index number of the lowest value of an array of numbers

function lowestIndex(arrayToTest) {
const lowest= null;
const position = -1;

for (let i = 0; i < arrayToTest.length; i++) {
  if (lowest === null) {
    lowest = arrayToTest[i];
    position = i;
  } else if (lowest > arrayToTest[i]) {
    lowest = arrayToTest[i];
    position = i;
  }
}
console.log(position);
};
//***************************************
/*The result may contain fives. ;-)
The start number will always be smaller than the end number. Both numbers can be also negative!

I'm very curious for your solutions and the way you solve it. Maybe someone of you will find an easy pure mathematics solution.

Have fun coding it and please don't forget to vote and rank this kata! :-)

I have also created other katas. Take a look if you enjoyed this kata! */

function dontGiveMeFive(start, end){
  let newArray = [];
  for (let i = start; i <= end; i += 1){
    newArray.push(i);
  }
  newArray = newArray.map((val) => {
    return "" + val;
  });
    newArray = newArray.filter((val) => {
      for (let i = 0; i < val.length; i += 1){
        if(!val.includes("5")){
          return val;
        }
      }
    });
    return newArray.length;
};
//***************************************
/*Check to see if a string has the same amount of 'x's and 'o's. The method must return a boolean and be case insensitive. The string can contains any char. */

function XO(str){
  var count = 0;
  str = str.toLowerCase();
  for(let i = 0; i < str.length; i++){
    if(str[i] === 'x') count++;
    if(str[i] === 'o') count--;
  }
  return count === 0 ? true : false;
};
//***************************************
/* 8kyu Complete the bool_to_word (Javascript: boolToWord ) method.

Given: a boolean value

Return: a 'Yes' string for true and a 'No' string for false */

function boolToWord( bool ){
  if(bool === true){
    return "Yes";
  } else if (bool === false) {
    return "No";
  }
};
//***************************************
/* Friend or Foe?: Make a program that filters a list of strings and returns a list with only your friends name in it.

If a name has 4 letters in it, you can be sure that it has to be a friend of yours!

Ex: Input = ["Ryan", "Kieran", "Jason", "Yous"], Output = ["Ryan", "Yous"] */

function friend(friends){
  var friendsArr = [];
  for (var i = 0; i < friends.length; i++) {
    if (friends[i].length === 4) {
      friendsArr.push(friends[i]);
    }
  }
  return friendsArr;
};
//***************************************
/* 7kyu Regex Validate Pin Code: ATM machines allow 4 or 6 digit PIN codes and PIN codes cannot contain anything but exactly 4 digits or exactly 6 digits. If the function is passed a valid PIN string, return true, else return false. */

function validatePIN (pin) {
  if (!isNaN(pin) && pin.length === 4 || pin.length === 6){
    return true;
  } else {
    return false;
  }
};
//***************************************
//Write word backwords
function reverseWord(str){
  const word = str.split("").reverse("").join("");
  console.log(word);
};
//***************************************
      //FizzBuzz
      function fizzBuzz(){
        for (let i = 0; i < 100; i ++){
          if(i % 3 === 0 && i % 5 === 0){
            console.log("FizzBuzz");
          } else if (i % 3 === 0) {
            console.log("Fizz");
          } else if (i % 5 === 0) {
            console.log("Buzz");
          } else {
            console.log(i);
          };
        };
      };
//***************************************
    </script>

  </body>
</html>
